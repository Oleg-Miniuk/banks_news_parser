(function(Mibew, $, _) {
    Mibew = _.extend(Mibew, {
        Views: {},
        Models: {},
        Thread: {
            id: 0,

            /**
             * Thread's token. Uses for verify thread
             * @type Number
             */
            token: 0,

            /**
             * Last message id received by the thread
             * @type Number
             */
            lastId: 0,

            /**
             * ID of the user related with the chat.
             * @type String
             */
            userId: null,

            /**
             * ID of the agent related with the chat.
             */
            agentId: null,

            /**
             * Thread's state
             * @type Number
             */
            state: null,
            defaults: {
                /**
                 * Id of the thread
                 * @type Number
                 */
                id: 0,

                /**
                 * Thread's token. Uses for verify thread
                 * @type Number
                 */
                token: 0,

                /**
                 * Last message id received by the thread
                 * @type Number
                 */
                lastId: 0,

                /**
                 * ID of the user related with the chat.
                 * @type String
                 */
                userId: null,

                /**
                 * ID of the agent related with the chat.
                 */
                agentId: null,

                /**
                 * Thread's state
                 * @type Number
                 */
                state: null
            },

            /** Thread state constants */

            /**
             * User in the users queue
             * Юзер в очереди
             */
            STATE_QUEUE: 0,
            /**
             * User waiting for operator
             * Юзер ждет оператора
             */
            STATE_WAITING: 1,
            /**
             * Conversation in progress
             * Диалог в процессе
             */
            STATE_CHATTING: 2,
            /**
             * Thread closed
             * Сессия закрыта
             */
            STATE_CLOSED: 3,
            /**
             * Thread just created
             * Сессия только что создан
             */
            STATE_LOADING: 4,
            /**
             * User left message without starting a conversation
             * Юзер покинул диалог без старта (сам завршил)
             */
            STATE_LEFT: 5,
            /**
             * Visitor was invited to chat by operator
             *
             */
            STATE_INVITED: 6
        },
        User: {
            defaults: {
                /**
                 * Collection of visitor controls
                 * @type Mibew.Collections.Controls
                 */
                controls: null,

                /**
                 * Name of the user
                 * @type String
                 */
                userName: '',

                /**
                 * Ip address of the user
                 * @type String
                 */
                userIp: '',

                /**
                 * Full remote address returned by web server. Generally
                 * equals to userIp.
                 * @type String
                 */
                remote: '',

                /**
                 * User agent
                 * @type String
                 */
                userAgent: '',

                /**
                 * Unix timestamp when visitor was first time observed
                 * on site
                 * @type Number
                 */
                firstTime: 0,

                /**
                 * Unix timestamp when visitor was first time observed
                 * on site
                 * @type Number
                 */
                lastTime: 0,

                /**
                 * Total invitations count
                 * @type Number
                 */
                invitations: 0,

                /**
                 * Total chats count with visitor
                 * @type Number
                 */
                chats: 0,

                /**
                 * Information about invitation or booean false if there is
                 * no invitation yet.
                 *
                 * Information object contains following keys:
                 *  - 'agentName': name of the agent who invited the visitor
                 *  - 'time': invitation time
                 * @type Object|Boolean
                 */
                invitationInfo: false,

                typing: false
            }
        },
        Messages: {
            defaults : {
                /**
                 * Message kind. See Mibew.Models.Message.KIND_* for details
                 * @type Number
                 */
                kind: null,

                /**
                 * Unix timestamp when message was created
                 * @type Number
                 */
                created: 0,

                /**
                 * Name of the message sender
                 * @type String
                 */
                name: '',

                /**
                 * Text of the message
                 * @type String
                 */
                message: '',

                /**
                 * Name of the plugin which sent the message. If message was not
                 * sent by a plugin it equals to an empty string.
                 * @type String
                 */
                plugin: '',

                /**
                 * Set of arbitrary data attached to the message.
                 * @type Object
                 */
                data: {}
            },

            /** Message kind constants */

            /** Message sent by user. */
            KIND_USER: 1,

            /** Message sent by operator */
            KIND_AGENT: 2,

            /** Hidden system message to operator */
            KIND_FOR_AGENT: 3,

            /** System messages for user and operator */
            KIND_INFO: 4,

            /** Message for user if operator have connection problems */
            KIND_CONN: 5,

            /** System message about some events (like rename). */
            KIND_EVENTS: 6,

            /** Message sent by a plugin */
            KIND_PLUGIN: 7
        },
        Status: {},
        MessageForm: {},
        Avatar: {
            imageLink: false
        }
    });
})(Mibew, chatJQ, _);

/**
 * Транспортный блок MIBEW
 *
 * @author   PDubkov
 * @version  1.0
 *
 * @param    {[type]}  Mibew     [description]
 * @param    {[type]}  MibewAPI  [description]
 * @param    {[type]}  $         [description]
 * @param    {[type]}  _         [description]
 * @return   {[type]}            [description]
 */
(function(Mibew, MibewAPI, $, _) {
    /**
     * This class implemets server interaction functionality
     * @todo May be make all private properties and methods _really_ private
     */
    Mibew.Server = function(options) {

        /**
         * Update timer
         */
        this.updateTimer = null;

        /**
         * Options for the Server object
         * @private
         */
        this.options = _.extend({
            // Server gateway URL
            url: "",
            // Time between requests (in seconds)
            requestsFrequency: 2,
            // Pause before restarting updater using Server.restartUpdater
            // function (in seconds)
            reconnectPause: 1,
            // Call on request timeout
            onTimeout: function() {},
            // Call when transport error was caught
            onTransportError: function() {},
            // Call when callFunctions related error was caught
            onCallError: function(e) {},
            // Call when update related error was caught
            onUpdateError: function(e) {},
            // Call when response related error was caught
            onResponseError: function(e) {}
        }, options);

        /**
         * Binds request's token and callback function
         * @type Object
         * @private
         */
        this.callbacks = {};

        /**
         * Contains periodically called functions
         * @type Object
         * @private
         */
        this.callPeriodically = {};

        /**
         * Id of the last added periodically called function
         * @type Number
         * @private
         */
        this.callPeriodicallyLastId = 0;

        /**
         * An object of the jqXHR class
         * @type jqXHR
         * @private
         */
        this.ajaxRequest = null;

        /**
         * This buffer store requests and responses between sending packages
         * @private
         */
        this.buffer = [];

        /**
         * Contains object of registered functions handlers
         * @type Object
         * @private
         */
        this.functions = {};

        /**
         * Id of the last registered function
         * @type Number
         * @private
         */
        this.functionsLastId = 0;

        /**
         * An instance of the MibewAPI class
         * @type MibewAPI
         * @private
         */
        // this.mibewAPI = new MibewAPI(new this.options['interactionType']());
    };

    /**
     * Make call to the server
     *
     * @param {Oblect[]} functionsList List of the function objects. See
     * Mibew API for details.
     * @param {Function} callbackFunction
     * @param {Boolean} forceSend Force requests buffer send right after call
     * @returns {Boolean} boolean true on success and false on failure
     */
    Mibew.Server.prototype.callFunctions = function(functionsList, callbackFunction, forceSend) {
        try {
            // Check function objects
            if (!(functionsList instanceof Array)) {
                throw new Error("The first arguments must be an array");
            }
            for (var i = 0; i < functionsList.length; i++) {
                // this.mibewAPI.checkFunction(functionsList[i], false);
                mibewAPI.checkFunction(functionsList[i], false);
            }

            // Generate request token
            var token = this.generateToken();
            // Store callback function
            this.callbacks[token] = callbackFunction;

            // Add request to buffer
            this.buffer.push({
                'token': token,
                'functions': functionsList
            });
            if (forceSend) {
                // Force update
                this.update();
            }
        } catch (e) {
            // Handle errors
            this.options.onCallError(e);
            return false;
        }
        return true;
    };

    /**
     * Call function at every request to build functions list
     *
     * @param {Function} functionsListBuilder Call before every request to build
     * a list of functions that must be called
     * @param {Function} callbackFunction Call after response received
     * @returns {Number} Id of added functions
     */
    Mibew.Server.prototype.callFunctionsPeriodically = function(functionsListBuilder, callbackFunction) {
        var _self = server;

        _self.callPeriodicallyLastId++;
        _self.callPeriodically[_self.callPeriodicallyLastId] = {
            functionsListBuilder: functionsListBuilder,
            callbackFunction: callbackFunction
        };
        return _self.callPeriodicallyLastId;
    };

    /**
     * Stop calling function at every request.
     *
     * @param {Number} id Id of the periodically called function, returned by
     * Mibew.Server.callFunctionsPeriodically method
     */
    Mibew.Server.prototype.stopCallFunctionsPeriodically = function(id) {
        var _self = server;

        if (id in _self.callPeriodically) {
            delete _self.callPeriodically[id];
        }
    };

    /**
     * Generates unique request token
     *
     * @private
     * @returns {String} Request token
     */
    Mibew.Server.prototype.generateToken = function() {
        var token;
        do {
            // Create random token
            token = "wnd" +
                (new Date()).getTime().toString() +
                (Math.round(Math.random() * 50)).toString();
        // Check token uniqueness
        } while(token in this.callbacks);
        return token;
    };

    /**
     * Process request
     *
     * @param {Object} requestObject Request object. See Mibew API for details.
     * @private
     */
    Mibew.Server.prototype.processRequest = function(requestObject) {
        var context = new MibewAPIExecutionContext();

        // Get result function
        var resultFunction = mibewAPI.getResultFunction(
            requestObject.functions,
            this.callbacks.hasOwnProperty(requestObject.token)
        );

        if (resultFunction === null) {
            // Result function not found
            // TODO: Try to use 'for' loop instead of 'for in' loop
            for (var i in requestObject.functions) {
                if (! requestObject.functions.hasOwnProperty(i)) {
                    continue;
                }
                // Execute functions
                this.processFunction(requestObject.functions[i], context);
                // Build and store result
                this.buffer.push(this.mibewAPI.buildResult(
                    context.getResults(),
                    requestObject.token
                ));
            }
        } else {
            // Result function found
            if (this.callbacks.hasOwnProperty(requestObject.token)) {
                // Invoke callback
                this.callbacks[requestObject.token](resultFunction.arguments);
                // Remove callback
                delete this.callbacks[requestObject.token];
            }
        }
    };

    /**
     * Process function
     *
     * @param {Object} functionObject Function object. See Mibew API for details
     * @param {MibewAPIExecutionContext} context Execution context
     * @private
     */
    Mibew.Server.prototype.processFunction = function(functionObject, context) {
        if (! this.functions.hasOwnProperty(functionObject["function"])) {
            return;
        }
        // Get function arguments with replaced refences
        var functionArguments = context.getArgumentsList(functionObject);

        var results = {};
        // TODO: Try to use 'for' loop instead of 'for in' loop
        for (var i in this.functions[functionObject["function"]]) {
            if (! this.functions[functionObject["function"]].hasOwnProperty(i)) {
                continue;
            }
            // Get results
            results = _.extend(results, this.functions[functionObject["function"]][i](
                functionArguments
            ));
        }

        // Add function results to the execution context
        context.storeFunctionResults(functionObject, results);
    };

    /**
     * Send the request to the server
     *
     * @param {Object[]} requestsList Array of requests that must be sent to the
     * server
     * @private
     */
    Mibew.Server.prototype.sendRequests = function(requestsList) {
        var self = this;
        // console.log(self.options.url, self.options);
        // debugger;
        // Create new AJAX request
        this.ajaxRequest = $.ajax({
            url: self.options.url,
            timeout: 5000,
            async: true,
            cache: false,
            type: 'POST',
            dataType: 'text',
            data: {
                data: mibewAPI.encodePackage(requestsList)
                // data: this.mibewAPI.encodePackage(requestsList)
                // data: requestsList
            },
            success: _.bind(self.receiveResponse, self),
            error: _.bind(self.onError, self)
        });
    };

    /**
     * Start automatic updater
     */
    Mibew.Server.prototype.runUpdater = function() {
        this.update();
    };

    /**
     * Call Mibew.Server.update after specified timeout
     * @param {Number} time Timeout in seconds
     * @private
     */
    Mibew.Server.prototype.updateAfter = function(time) {
        this.updateTimer = setTimeout(
            _.bind(this.update, this),
            time * 1000
        );
    };

    /**
     * Restarts the automatic updater
     */
    Mibew.Server.prototype.restartUpdater = function() {
        // Clear timeout
        if (this.updateTimer) {
            clearTimeout(this.updateTimer);
        }
        // Abort current AJAX request if it exist
        if (this.ajaxRequest) {
            this.ajaxRequest.abort();
        }
        // Restart updater. Try to reconnect after a while
        this.updateAfter(this.options.reconnectPause);
    };

    /**
     * Send request to server
     * @private
     */
    Mibew.Server.prototype.update = function() {
        if (this.updateTimer) {
            clearTimeout(this.updateTimer);
        }
        for (var i in this.callPeriodically) {
            if (! this.callPeriodically.hasOwnProperty(i)) {
                continue;
            }
            this.callFunctions(
                this.callPeriodically[i].functionsListBuilder(),
                this.callPeriodically[i].callbackFunction
            );
        }
        // Check buffer length
        if (this.buffer.length == 0) {
            // Rerun updater later
            this.updateAfter(this.options.requestsFrequency);
            return;
        }
        try {
            // Send requests
            this.sendRequests(this.buffer);
            // Clear requests buffer
            this.buffer = [];
        } catch (e) {
            // Handle errors
            this.options.onUpdateError(e);
        }
    };

    /**
     * Process response from the Server
     *
     * @param {String} data The response text
     * @param {String} textStatus Request status
     * @param {jqXHR} jqXHR jQuery AJAX request object
     * @private
     */
    Mibew.Server.prototype.receiveResponse = function(data, textStatus, jqXHR) {
        // Do not parse empty responses
        if (data == '') {
            this.updateAfter(this.options.requestsFrequency);
        }
        try {
            var packageObject = mibewAPI.decodePackage(data);
            // console.log(packageObject.requests);
            // TODO: Try to use 'for' loop instead of 'for in' loop
            // or use hasOwnProperty method
            for (var i in packageObject.requests) {
                this.processRequest(packageObject.requests[i]);
            }
        } catch (e) {
            this.options.onResponseError(e);
        } finally {
            this.updateAfter(this.options.requestsFrequency);
        }
    };

    /**
     * Add function that can be called by the Server
     *
     * @param {String} functionName Name of the function
     * @param {Function} handler Provided function
     * @returns {Number} Id of registered function
     */
    Mibew.Server.prototype.registerFunction = function(functionName, handler) {
        this.functionsLastId++;
        if (!(functionName in this.functions)) {
            this.functions[functionName] = {};
        }
        this.functions[functionName][this.functionsLastId] = handler;
        return this.functionsLastId;
    };

    /**
     * Remove function that can be called by Server
     *
     * @param {Number} id Id of function returned by
     * Mibew.Server.registerFunction method
     */
    Mibew.Server.prototype.unregisterFunction = function(id) {
        for (var i in this.functions) {
            if (! this.functions.hasOwnProperty(i)) {
                continue;
            }
            if (id in this.functions[i]) {
                delete this.functions[i][id];
            }
            if (_.isEmpty(this.functions[i])) {
                delete this.functions[i];
            }
        }
    };

    /**
     * Call on AJAX errors
     *
     * @param {jqXHR} jqXHR jQuery AJAX request object
     * @param {String} textStatus Request status
     * @param {String} errorThrown Contain text part HTTP status if HTTP error
     * occurs
     */
    Mibew.Server.prototype.onError = function(jqXHR, textStatus, errorThrown) {
        if (textStatus != 'abort') {
            this.restartUpdater();
            if (textStatus == 'timeout') {
                this.options.onTimeout();
            } else if (textStatus == 'error') {
                this.options.onTransportError();
            }
        }
    };
})(Mibew, MibewAPI, chatJQ, _);

/**
 * Разъем для работы с Автаром
 *
 * @author   PDubkov
 * @version  1.0
 *
 * @param    {[type]}  Mibew  [description]
 * @param    {[type]}  _      [description]
 * @param    {[type]}  $      [description]
 * @return   {[type]}         [description]
 */
(function(Mibew, _, $) {
    /**
     * @class Represents agent's avatar
     */
    Mibew.Avatar = $.extend({},
        /** @lends Mibew.Models.Avatar.prototype */
        {
            /**
             * An URL of the avatar image or false by default.
             * @type String|Boolean
             */
            imageLink: false,

            /**
             * Model initializer.
             */
            initialize: function() {

                /**
                 * Contain ids of registered by the model api functions
                 * @type Array
                 */
                var _self = Mibew.Avatar;
                // this.registeredFunctions = [];
                _self.registeredFunctions = [];

                // Register API function
                _self.registeredFunctions.push(
                    server.registerFunction(
                        'setupAvatar',
                        _.bind(_self.apiSetupAvatar, _self)
                    )
                );

                // Update avatar if operator changed.
                // Mibew.Objects.Models.thread.on(
                //     'change:agentId',
                //     this.setFromThread,
                //     this
                // );
            },

            // Model finalizer
            finalize: function() {
                // Unregister api functions
                for (var i = 0; i < this.registeredFunctions.length; i++) {
                    server.unregisterFunction(
                        this.registeredFunctions[i]
                    );
                }

                this.imageLink = false;
            },

            /**
             * Set avatar
             * This is an API function.
             * @param args {Object} An object of passed arguments
             */
            apiSetupAvatar: function(args) {
                this.imageLink = (args.imageLink || false);
            },

            /**
             * Sets avatar based on data from the thread.
             * @param {Object} thread An instance of Mibew.Models.Thread
             */
            setFromThread: function(thread) {
                // debugger;
                if (!thread.agentId) {
                    // There is no operator. Hide the avatar.
                    this.imageLink = false;
                    return;
                }

                // Request operator's avatar at the server side
                server.callFunctions(
                    [{
                        'function': 'getAvatar',
                        'arguments': {
                            'references': {},
                            'return': {
                                'imageLink': 'imageLink'
                            },
                            'threadId': thread.id,
                            'token': thread.token
                        }
                    }],
                    _.bind(this.apiSetupAvatar, this),
                    true
                );
            }
        }
    );
})(Mibew, _, chatJQ);


/**
 * Интерфейс для передачи сообщений
 *
 * @author   PDubkov
 * @version  1.0
 *
 * @param    {[type]}  Mibew  [description]
 * @param    {[type]}  $      [description]
 * @param    {[type]}  _      [description]
 * @return   {[type]}         [description]
 */
(function(Mibew, $, _){
    /**
     * @class Represents messages list
     */
    Mibew.Messages = $.extend(true, {}, Mibew.Messages,
        /** @lends Mibew.Collections.Message.prototype */
        {
            /**
             * Default contructor for model
             * @type Function
             */
            // model: Mibew.Models.Message,

            /**
             * Collection initializer.
             */
            initialize: function() {

                /**
                 * Contains ids of periodically called functions
                 * @type Array
                 */
                _self = Mibew.Messages;
                this.periodicallyCalled = [];
                _self.periodicallyCalled = [];


                // Periodically try to get new messages
                _self.periodicallyCalled.push(
                    Mibew.Server.prototype.callFunctionsPeriodically(
                        _.bind(_self.updateMessagesFunctionBuilder, _self),
                        _.bind(_self.updateMessages, _self)
                    )
                );
            },

            /**
             * Collection finalizer
             */
            finalize: function() {
                // Stop call functions periodically
                for (var i = 0; i < this.periodicallyCalled.length; i++) {
                    Mibew.Server.prototype.stopCallFunctionsPeriodically(
                        this.periodicallyCalled[i]
                    );
                }
            },

            /**
             * Update messages if they are exist.
             * @param args {Object} An object of passed arguments
             */
            _prevSTATE: null,
            _operatorData: {},
            updateMessages: function(args) {
                // console.log(args);
                // Update last message id
                if (args.lastId) {
                    // Mibew.Objects.Models.thread.set({lastId: args.lastId});
                    Mibew.Thread.lastId = args.lastId;
                }

                _self = this;

                // Use shortcut for KIND_PLUGIN
                var kindPlugin = Mibew.Messages.KIND_PLUGIN;

                // Get all new messages
                var newMessages = [];
                var messageData, pluginName, eventName, eventArgs;
                for(var i = 0, length = args.messages.length; i < length; i++) {
                    messageData = args.messages[i];
                    if (messageData.kind != kindPlugin) {
                        // Message have one of the core kinds. Just store it.
                        // newMessages.push(
                        //     new Mibew.Models.Message(messageData)
                        // );

                        // console.log(messageData);
                        newMessages.push(
                            messageData
                        );

                        // первый ответ оператора
                        if (messageData.kind == Mibew.Messages.KIND_AGENT &&
                            Mibew.Thread.state == Mibew.Thread.STATE_CHATTING
                        ) {
                            // "operatorId"    : 123,
                            if (!_self._operatorData.operatorId) _self._operatorData.operatorId = Mibew.Thread.agentId;
                            // "operatorName"  : "Оператор",
                            if (!_self._operatorData.operatorName) _self._operatorData.operatorName = messageData.name;
                            // "dialogId"      : 321
                            if (!_self._operatorData.dialogId) _self._operatorData.dialogId = Mibew.Thread.id;
                            // "operatorAvatar": Mibew.Avatar.imageLink || null,
                            if (!_self._operatorData.operatorAvatar) {
                                if (!Mibew.Avatar.imageLink)
                                    Mibew.Avatar.setFromThread(Mibew.Thread);
                                _self._operatorData.operatorAvatar = Mibew.Avatar.imageLink;
                            }
                            // console.log(_self._operatorData);
                            // CHANGED: убрал обязательное значение аватара
                            var tempOpData = _self._operatorData;
                            if (tempOpData.operatorId && tempOpData.operatorName &&
                                tempOpData.dialogId /*&& tempOpData.operatorAvatar*/) {

                                if (!Mibew.operatorDataAlreadySended) {
                                    Mibew.trigger('dopOperatorsDate', tempOpData);
                                    Mibew.operatorDataAlreadySended = true;
                                    _self._operatorData = {};
                                }

                            }
                        }

                        // сообщение ОТ оператора
                        if (messageData.kind == Mibew.Messages.KIND_AGENT && this._prevSTATE) {
                            Mibew.trigger('nns_operatorTextSent', {
                                "ts"       : messageData.created,
                                "message"  : messageData.message,
                                "messageId": messageData.id
                            });
                        }
                        continue;
                    }

                    // Message have KIND_PLUGIN kind and need to be processed
                    // by plugins to know how to display it.

                    // Check if message is an real Object
                    if ((typeof messageData.data != 'object')
                        || (messageData.data === null)) {
                        continue;
                    }

                    // Prepare event name.
                    //
                    // If plugin name was specified it will be
                    // 'process:<plugin_name>:plugin:message' and
                    // 'process:plugin:message' otherwise.
                    // pluginName = messageData.plugin || false;
                    // eventName = 'process:'
                    //     + ((pluginName !== false) ? pluginName + ':' : '')
                    //     + 'plugin:message';

                    // Prepare event arguments.
                    //
                    // It is an object with following fields:
                    //  - 'messageData': object which contains message data
                    //    passed from server.
                    //  - 'model': message model initialized by the plugin or
                    //    boolean false if message should not be displayed. By
                    //    default it field equals to boolean false.
                    // eventArgs = {
                    //     'messageData': messageData,
                    //     'model': false
                    // }

                    // Trigger event. See description of eventName and eventArgs
                    // above.
                    // Mibew.trigger(eventName, eventArgs);

                    // if (eventArgs.model) {
                    //     // Check if plugin set message id
                    //     if (! eventArgs.model.get('id')) {
                    //         // Message must have an id, set it
                    //         eventArgs.model.set({'id': messageData.id});
                    //     }

                    //     // Store custom plugin message in the collection
                    //     newMessages.push(
                    //         eventArgs.model
                    //     );
                    // }
                }

                // console.log(Mibew.Thread.state);
                if (
                    Mibew.Thread.state == Mibew.Thread.STATE_CHATTING &&
                    // this._prevSTATE !== null ||
                    this._prevSTATE != Mibew.Thread.state
                ) {
                    // CHANGED: определяем аватар оператор
                    // debugger;
                    if (!Mibew.Avatar.imageLink)
                        Mibew.Avatar.setFromThread(Mibew.Thread);
                    // console.log(args);
                    Mibew.trigger('nns_operatorPersonAssigned', {
                        "operatorId"    : Mibew.Thread.agentId,
                        "operatorAvatar": Mibew.Avatar.imageLink || null,
                        "operatorName"  : "Оператор",
                        "dialogId"      : Mibew.Thread.id
                    });
                }
                this._prevSTATE = Mibew.Thread.state;

                if (Mibew.Thread.state == Mibew.Thread.STATE_CLOSED) {
                    // TODO: ЧАТ ЗАВЕРШЕН - вызвать финализацию
                    Mibew.finalize();
                }

                // Add new messages to the message collection if there are any
                // messages
                if (newMessages.length > 0) {
                    // this.add(newMessages);
                }
            },

            /**
             * Builds updateMessages function, that should be called
             * periodically at the server side
             * @returns {Object[]} Array of functions objects
             */
            updateMessagesFunctionBuilder: function() {
                // Get thread and user objects
                // debugger;
                var thread = Mibew.Thread;
                var user = Mibew.User;

                // Build functions list
                return [
                    {
                        "function": "updateMessages",
                        "arguments": {
                            "return": {
                                'messages': 'messages',
                                'lastId': 'lastId'
                            },
                            "references": {},
                            "threadId": thread.id,
                            "token": thread.token,
                            "lastId": thread.lastId,
                            "user": (! user.isAgent)
                        }
                    }
                ];
            },

            /**
             * Override Backbone.Collection.add method to call additional event
             */
            add: function() {
                // TODO: ?????
                /*// Get arguments list
                var args = Array.prototype.slice.apply(arguments);
                // Call method of the parent class
                var res = Backbone.Collection.prototype.add.apply(this, args);
                // Triggers additional event
                Mibew.trigger('multiple:add');
                return res;*/
            }
        }
    );
})(Mibew, chatJQ, _);

/**
 * Методы для отправки сообщения от пользователя
 *
 * @author   PDubkov
 * @version  1.0
 *
 * @param    {[type]}  Mibew  [description]
 * @param    {[type]}  _      [description]
 * @return   {[type]}         [description]
 */
 (function(Mibew, $){
     /**
      * @class Represents message form model
      */
     Mibew.MessageForm = $.extend({},
         /** @lends Mibew.Models.MessageForm.prototype */
         {
             /**
              * A list of default model values.
              * @type Object
              */
             defaults: {
                 /**
                  * Array of predifined answers
                  * @type Array
                  */
                 predefinedAnswers: [],

                 /**
                  * Indicates if Enter or Ctrl+Enter should send message
                  * @type Boolean
                  */
                 ignoreCtrl: false
             },

             /**
              * Post message.
              * Send message to the server and run callback function after that.
              * @param {String} msg Message to send
              */
             postMessage: function(msg) {
                 // Get thread and user objects
                 var thread = Mibew.Thread;
                 var user = Mibew.User;

                 // Check if user can post a message
                 if (! user.canPost) {
                     return;
                 }

                 // debugger;
                 // Triggers before post event
                 Mibew.trigger('before:post', this);

                 // Store link to the object
                 var self = this;

                 // Post message to the server
                 server.callFunctions(
                     [{
                         "function": "post",
                         "arguments": {
                             "references": {},
                             "return": {},
                             "message": msg,
                             "threadId": thread.id,
                             "token": thread.token,
                             "user": (! user.isAgent)
                         }
                     }],
                     function(args) {
                        // console.log(args);
                         Mibew.trigger('after:post', self);
                     },
                     true
                 );
             }
         }
     );
 })(Mibew, chatJQ);


// Инициализации
(function(Mibew, $, _) {
    Mibew = _.extend(Mibew, {
        chatIsStarted: false,
        operatorDataAlreadySended: false,

        trigger: function(event, data) {
            // Set default value for data argument if it is not passed in.
            if (typeof data === 'undefined') {
                data = {};
            }
            // console.log(event, data);
            $(window).trigger('from-mibew', {'event':event, 'data':data});
            // if (!invitaionEventsCallbacks.hasOwnProperty(event)) {
            //     // There is no callback for the event. So there is no reasons to
            //     // continue.
            //     return;
            // }

            // Run callbacks one by one
            // var callbacks = invitaionEventsCallbacks[event];
            // for(var i = 0, length = callbacks.length; i < length; i++) {
            //     callbacks[i](data);
            // }
        },
        // periodicallyCalled: [],
        buildChatUrl: function(url, grpID) {
            var href = document.location.href,
                referrer = document.referrer;

            // CHANGED: убрали протоколы для избежания ошибки смешанных протоколов
            if (this.modSecurity) {
                href = href.replace('http://','').replace('https://','');
                referrer = referrer.replace('http://','').replace('https://','');
            }

            url = url.replace('http://','//').replace('https://','//');

            // CHANGED: если есть grpID докомпоновываем строку на определенную группу операторов
            groupPart = (grpID && typeof grpID !== "undefined")
                        ? "&group="+grpID
                        : '';

            return url
                + ((url.indexOf('?') === -1) ? '?' : '&') + 'url=' + encodeURIComponent(href)
                + '&referrer=' + encodeURIComponent(referrer)
                + groupPart;
        },
        getServerParams: function (requestParams) {},

        checkOperators: function(grpID){
            var self = this,
                grpID = (grpID && typeof grpID !== "undefined") ? grpID : null;
            var url = this.buildChatUrl('chat/operators/online', grpID);
            $.getJSON(url)
                .success(function(data) {
                    if (typeof data !== 'undefined'){
                        if (data.hasOperators) {
                            self.trigger('nns_livechatStatusRequested', {
                                "hasOnlineOperators": true,
                                "freeOperatorsCount": 1
                            });
                        } else {
                            self.trigger('nns_livechatStatusRequested', {
                                "hasOnlineOperators": false,
                                "freeOperatorsCount": 0
                            });
                        }
                    }
                })
                .error(function() { console.log("Ошибка выполнения запроса"); });
        },
        init: function (options) {
            var self = this;
            var url = this.buildChatUrl(options.url);
            $.getJSON(url)
                .success(function(data) {
                    if (typeof data !== 'undefined'){
                        if (data.startFrom === 'leaveMessage') {
                            // console.log("Доп.проверка по факту подключения");
                            self.trigger('nns_livechatStatusRequested', {
                                "hasOnlineOperators": false,
                                "freeOperatorsCount": 0
                            });
                        } else {
                            // CHANGED: Отправляем к виджету данные о сессии соператором (чтобы потом проставить оценку)
                            self.trigger('nlab_threadData', {
                                thread_id: data.thread_id,
                                token    : data.token
                            });

                            // CHANGED: Исправил определение верного урла для локалки
                            var _url = (window.location.host === "mibew.local") ?
                                        '//'+ window.location.host +'/mibew/chat/' + data.thread_id +'/'+ data.token :
                                        '//'+ window.location.host +'/chat/' + data.thread_id +'/'+ data.token;
                            var newUrl = self.buildChatUrl(_url);

                            $.getJSON(newUrl).success(function(data) {
                                self.start(data);
                            });
                        }
                    }
                })
                .error(function() { console.log("Ошибка выполнения запроса"); });
        },
        // periodicallyCalled: [],
        globalIsTyped: false,
        start: function (options) {
            if (this.chatIsStarted) return;
            this.chatIsStarted = true;
            this.operatorDataAlreadySended = false;
            MibewAPIChatInteraction = function() {
                this.mandatoryArguments = function() {
                    return {
                        '*': {
                            'threadId': null,
                            'token': null,
                            'return': {},
                            'references': {}
                        },
                        'result': {
                            'errorCode': 0
                        }
                    };
                };

                this.getReservedFunctionsNames = function() {
                    return [
                        'result'
                    ];
                };
            };
            MibewAPIChatInteraction.prototype = new MibewAPIInteraction();
            mibewAPI = new MibewAPI(MibewAPIChatInteraction.prototype);

            this.periodicallyCalled = [];

            Mibew.Thread = $.extend(Mibew.Thread, options.chatOptions.thread);
            Mibew.User = $.extend(Mibew.User, Mibew.User.defaults, options.chatOptions.user);

            server = new Mibew.Server(_.extend(
                {'interactionType': MibewAPIChatInteraction},
                options.server
            ));

            // server = new Mibew.Server(options.server);
            mess = new Mibew.Messages.initialize();
            var _self = this;
            this.periodicallyCalled.push(
                server.callFunctionsPeriodically(
                    function() {
                        // Get thread and user objects
                        var thread = Mibew.Thread;
                        var user = Mibew.User;

                        // Build functions list
                        return [
                            {
                                "function": "update",
                                "arguments": {
                                    "return": {
                                        'threadState': 'threadState',
                                        'threadAgentId': 'threadAgentId',
                                        'typing': 'typing',
                                        'canPost': 'canPost'
                                    },
                                    "references": {},
                                    "threadId": thread.id,
                                    "token": thread.token,
                                    "lastId": thread.lastId,
                                    "typed": user.typing,
                                    "user": (! user.isAgent)
                                }
                            }
                        ];
                    },
                    function(args) {
                        // Check if there was an error
                        if (args.errorCode) {
                            console.log(args.errorMessage || 'Cannot close');
                            // Mibew.Objects.Models.Status.message.setMessage(
                            //     args.errorMessage || 'refresh failed'
                            // );
                            return;
                        }

                        // Update typing status
                        if (args.typing) {
                            if (_self.globalIsTyped) return;
                            setTimeout(function(){
                                _self.globalIsTyped = false;
                            }, 6000);
                            Mibew.trigger('nns_operatorTyped');
                            _self.globalIsTyped = true;
                        }

                        // Update user
                        Mibew.User.canPost = args.canPost || false;

                        // debugger;
                        // Update thread fields
                        if (!_self.Finalled && typeof _self.Finalled !== "undefined") {
                            Mibew.Thread.agentId = args.threadAgentId;
                            Mibew.Thread.state = args.threadState;
                        } else {
                            _self.Finalled = false;
                        }
                    }
                )
            );

            // Определить аватар оператора
            avatar = new Mibew.Avatar.initialize();
            if (options.chatOptions.avatar !== "")
                Mibew.Avatar.imageLink = options.chatOptions.avatar;

            server.runUpdater();

        },
        // Закрытие потока по инициативе пользователя
        threadCloseByUser: false,
        closeThread: function() {
            // Get thread and user objects
            var thread = Mibew.Thread;
            var user = Mibew.User;
            var _self = this;
            // Send request to the server
            server.callFunctions(
                [{
                    "function": "close",
                    "arguments": {
                        "references": {},
                        "return": {"closed": "closed"},
                        "threadId": thread.id,
                        "token": thread.token,
                        "lastId": thread.lastId,
                        "user": (! user.isAgent)
                    }
                }],
                function(args){
                    if (args.closed) {
                        // Mibew.Utils.closeChatPopup();
                        // Событие закрытия чата ЮЗЕРОМ
                        Mibew.trigger('nns_switchToVishnu', {
                            "status": "userEnd"
                        });
                        _self.threadCloseByUser = true;
                    } else {
                        // Something went wrong. Display error message
                        console.log(args.errorMessage || 'Cannot close');
                        // Mibew.Objects.Models.Status.message.setMessage(
                        //     args.errorMessage || 'Cannot close'
                        // );
                    }
                },
                true
            );
        },

        // Создает верный урл по параметрам
        buildUrlFromParams: function(rout, args) {
            // Добавим базовый урл как начальный элемент массива
            var _baseUrl  = (window.location.host === "mibew.local") ?
                    '//'+ window.location.host +'/mibew' :
                    '//'+ window.location.host;

            args.unshift(rout);
            args.unshift(_baseUrl);

            return args.join('/');
        },
        // Оценить диалог
        rateThread: function(threadData, rate) {
            if (typeof rate === "undefined" || !rate) throw new Error('Отсутсвтует оценка диалога с оператором');
            if (typeof threadData === "undefined" || !threadData) throw new Error('Отсутсвтуют данные thread');

            var _self  = this,
                _url   = this.buildUrlFromParams('chat', [
                    threadData.thread_id,
                    threadData.token,
                    rate
                ]);
            // Запросили JSON оценки
            $.getJSON(_url).success(function(data) {
                // TODO: Залогинить ошибку, при успехе ничего не делать
                // debugger;
                // console.log(data);
            });
        },

        // проброс лога диалога к оператору
        logSent: function(logObject){
            if (!logObject.length) {
                return; // empty log -- do nothing
            }

            // var user = Mibew.User;
            var thread = Mibew.Thread;
            var _self = this;

            // ставим флаг отправки на пользовательские сообщения
            Mibew.User.isAgent = false;
            // $.each(logObject, function(i, val){
            //     // отправить сообщение
            //     var logMessage = (val.inf) ? 'ИНФ: '+val.inf : val.user;
            //     Mibew.MessageForm.postMessage(logMessage);
            // });

            // CHANGED: Исправление для верной отправки данных
            for (var i = 0; i < logObject.length; i++) {
                (function(ind) {
                    setTimeout(function(){
                        var val        = logObject[ind],
                            logMessage = (val.inf) ? 'ИНФ: '+ val.inf : val.user;
                        Mibew.MessageForm.postMessage(logMessage);
                    }, 300 * ind);
                })(i);
            }

        },
        // Флаг показывающий финализацию
        Finalled: false,
        // TODO: сделать завершение сессии
        finalize: function(){
            // Stop call functions periodically
            for (var i = 0; i < this.periodicallyCalled.length; i++) {
                // debugger;
                server.stopCallFunctionsPeriodically(
                    this.periodicallyCalled[i]
                );
            }

            // Run models finalizers
            // Finalize avatar model
            if (typeof Mibew.Avatar != 'undefined') {
                Mibew.Avatar.finalize();
            }

            if (this.threadCloseByUser){
                this.threadCloseByUser = false;
            } else {
                Mibew.trigger('nns_switchToVishnu', {
                    "status": "operatorEnd"
                });
            }

            // Finalize messages collection
            Mibew.Messages.finalize();

            // переопределяем очередь
            Mibew.Thread = $.extend({}, Mibew.Thread, Mibew.Thread.defaults);

            // переопределяем юзера
            tempUser = {};
            tempUser.defaults = $.extend(true, {}, Mibew.User.defaults);
            delete Mibew.User;
            Mibew.User = $.extend(true, {}, tempUser);
            // поднимаем флаг финализации
            this.Finalled = true;
            this.chatIsStarted = false;
            this.operatorDataAlreadySended = false;
        }
    });
})(Mibew, chatJQ, _);


